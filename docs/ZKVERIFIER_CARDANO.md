ZKVerifier (Cardano) â€” Zero-Knowledge Proof Verification Specification

This document defines the ZKVerifierCardano, the Cardano-side verification module used by the ZKADA bridge to validate Zero-Knowledge proofs generated by a zkVM (RISC Zero or SP1).

It ensures that ADA locked on Cardano is only released after a valid and cryptographically sound proof originating from the Cosmos side is verified.

ðŸ”· 1. Purpose

ZKVerifierCardano is responsible for:

verifying incoming ZK proofs

validating state consistency

ensuring no forged proof can unlock ADA

enabling trustless cross-chain value flow

providing deterministic verification logic

It works hand-in-hand with the LockBoxADA validator script.

ðŸ”· 2. High-Level Flow

The verification process:

Cosmos burns cADA

Cosmos state is interpreted by zkVM

zkVM generates a zero-knowledge proof

Proof is submitted to Cardano

ZKVerifierCardano validates the proof

LockBoxADA releases ADA to the user

All steps must be trustless and reproducible.

ðŸ”· 3. Input Format

The redeemer for verification contains:

Field	Type	Description
zk_proof	bytes	Full ZK proof blob (RISC Zero or SP1)
proof_commitment	bytes32	Hash commitment of the proof
expected_state_hash	bytes32	Hash of expected Cosmos state
burn_tx_hash	bytes32	Hash of cADA burn transaction
recipient_address	bytes	ADA receiver

This allows the contract to validate all necessary state transitions.

ðŸ”· 4. Verification Steps
4.1 Proof Integrity Check

Validate proof_commitment == hash(zk_proof)

Ensures the proof is not tampered with

4.2 ZK Proof Verification

Cardano calls an on-chain verification primitive which:

parses proof structure

checks validity according to RISC Zero or SP1 public parameters

ensures proof was generated from correct Circuit ID

confirms prover cannot manipulate inputs

If Cardano cannot natively verify large proofs in Phase 1, a hashed commitment + off-chain validation model will be analyzed as part of feasibility.

4.3 State Consistency Check

The verified proof must contain Cosmos burn state

expected_state_hash must match the state hash derived inside the ZK proof

Prevents forged proofs or fake burns

4.4 Replay Protection

Each burn_tx_hash is accepted only once

Prevents repeating unlocks for the same burn

ðŸ”· 5. Validation Criteria

A proof is valid if:

proof structure is correct

commitment matches

ZK proof verifies

state hash matches

burn is valid and unique

recipient is correctly specified

Otherwise â†’ reject.

ðŸ”· 6. Implementation Notes
6.1 Language

Implemented using Aiken or Plutus V2

Prefer Aiken for cleaner type definitions

6.2 Storage

Contract does not maintain long-term state.
Replay protection handled via:

lock ID tracking

burn hash tracking

hashed commitments stored in UTxO datum

6.3 Deterministic Requirements

All calculations must be:

reproducible

deterministic

byte-accurate

hash-consistent between Cardano and zkVM

ðŸ”· 7. Phase 1 Deliverables

This document contributes to:

Milestone 2 â€“ Cardano contract specification

Milestone 4 â€“ zkVM feasibility

Milestone 5 â€“ security model

Full implementation is planned for Phase 2.
